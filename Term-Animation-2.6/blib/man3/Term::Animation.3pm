.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Term::Animation 3pm"
.TH Term::Animation 3pm "2011-03-29" "perl v5.32.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Animation \- ASCII sprite animation framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Term::Animation;
\&
\&  # Constructors
\&  $anim = Term::Animation\->new();
\&  $anim = Term::Animation\->new($curses_window);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
A framework to produce sprite animations using \s-1ASCII\s0 art.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a framework to produce sprite animations using
\&\s-1ASCII\s0 art. Each \s-1ASCII\s0 'sprite' is given one or more frames, and placed
into the animation as an 'animation object'. An animation object can
have a callback routine that controls the position and frame of the
object.
.PP
If the constructor is passed no arguments, it assumes that it is 
running full screen, and behaves accordingly. Alternatively, it can
accept a curses window (created with the Curses \fInewwin\fR call) as an
argument, and will draw into that window.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example moves a small object across the screen from left to right.
.PP
.Vb 2
\&    use Term::Animation;
\&    use Curses;
\&
\&    $anim = Term::Animation\->new();
\&
\&    # set the delay for getch
\&    halfdelay( 2 );
\&
\&    # create a simple shape we can move around
\&    $shape = "<=O=>";
\&
\&    # turn our shape into an animation object
\&    $anim\->new_entity(
\&                 shape         => $shape,        # object shape
\&                 position      => [3, 7, 10],    # row / column / depth
\&                 callback_args => [1, 0, 0, 0],  # the default callback
\&                                                 #  routine takes a list
\&                                                 #  of x,y,z,frame deltas
\&                 wrap          => 1              # turn screen wrap on
\&    );
\&
\&    # animation loop
\&    while(1) {
\&      # run and display a single animation frame
\&      $anim\->animate();
\&
\&      # use getch to control the frame rate, and get input at the
\&      # same time. (not a good idea if you are expecting much input)
\&      my $input = getch();
\&      if($input eq \*(Aqq\*(Aq) { last; }
\&    }
\&
\&    # cleanly end the animation, to avoid hosing up the user\*(Aqs terminal
\&    $anim\->end();
.Ve
.PP
This illustrates how to draw your animation into an existing Curses window.
.PP
.Vb 2
\&    use Term::Animation;
\&    use Curses;
\&
\&    # Term::Animation will not call initscr for you if
\&    # you pass it a window
\&    initscr();
\&
\&    $win = newwin(5,10,8,7);
\&
\&    $anim = Term::Animation\->new($win);
.Ve
.PP
Everything else would be identical to the previous example.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew\fR" 4
.IX Item "new"
.Vb 2
\&  $anim = Term::Animation\->new();
\&  $anim = Term::Animation\->new($curses_window);
.Ve
.Sp
The constructor. Optionally takes an existing curses window
to draw in.
.IP "\fInew_entity\fR" 4
.IX Item "new_entity"
.Vb 5
\&  $anim\->new_entity(
\&        shape         => $shape,
\&        position      => [ 1, 2, 3 ],
\&        callback_args => [ 1, 0, 0 ]
\&  );
.Ve
.Sp
Creates a new Term::Animation::Entity object and adds it to the
animation. This is identical to:
.Sp
.Vb 2
\&  my $entity = Term::Animation::Entity\->new(...);
\&  $anim\->add_entity($entity);
.Ve
.Sp
See Term::Animation::Entity/PARAMETERS and Term::Animation::Entity/new
in Term::Animation::Entity for details on calling this method.
.IP "\fIcolor_name\fR" 4
.IX Item "color_name"
.Vb 1
\&  $name = $anim\->color_name( $color );
.Ve
.Sp
Returns the full name of a color, given either a full
name or a single character abbreviation.
.IP "\fIcolor_id\fR" 4
.IX Item "color_id"
.Vb 1
\&  $id = $anim\->color_id( $color );
.Ve
.Sp
Returns the single character abbreviation for a color, 
given either a full name or abbreviation.
.IP "\fIis_valid_color\fR" 4
.IX Item "is_valid_color"
.Vb 1
\&  my $is_valid = $anim\->is_valid_color($color_name);
.Ve
.Sp
Returns true if the supplied string is a valid color name ('blue')
or a valid color id ('b').
.IP "\fIcolor\fR" 4
.IX Item "color"
.Vb 2
\&  my $state = $anim\->color();
\&  $anim\->color($new_state);
.Ve
.Sp
Enable or disable \s-1ANSI\s0 color. This \s-1MUST\s0 be called immediately after creating
the animation object if you want color, because the Curses start_color call must 
be made immediately. You can then turn color on and off whenever you want.
.IP "\fIbackground\fR" 4
.IX Item "background"
.Vb 1
\&  $anim\->background( $color );
.Ve
.Sp
Change the background color. The default background color is black. You
can only have one background color for the entire Curses window that
the animation is running in.
.IP "\fIanimate\fR" 4
.IX Item "animate"
.Vb 1
\&  $anim\->animate();
.Ve
.Sp
Perform a single animation cycle. Runs all of the callbacks,
does collision detection, and updates the display.
.IP "\fItrack_framerate\fR" 4
.IX Item "track_framerate"
.Vb 2
\&  $anim\->track_framerate(1);
\&  $tracking_framerate = $anim\->track_framerate();
.Ve
.Sp
Get or set the flag that indicates whether the module
should keep track of the animation framerate. This is
enabled by default.
.IP "\fIframerate\fR" 4
.IX Item "framerate"
.Vb 1
\&  $frames_per_second = $anim\->framerate();
.Ve
.Sp
Returns the approximate number of frames being displayed
per second, as indicated by calls to the \fIanimate\fR method.
.IP "\fIscreen_size\fR" 4
.IX Item "screen_size"
.Vb 1
\&  my ($width, $height, $assumed_size) = $anim\->screen_size();
.Ve
.Sp
Returns the width and height of the screen. The third value
returned is a boolean indicating whether or not the default
screen size was used, because the size could not be determined.
.IP "\fIupdate_term_size\fR" 4
.IX Item "update_term_size"
.Vb 1
\&  $anim\->update_term_size();
.Ve
.Sp
Call this if you suspect the terminal size has changed (eg. if you
get a \s-1SIGWINCH\s0 signal). Call \fIremove_all_entities\fR after this if
you want to recreate your animation from scratch.
.IP "\fIadd_entity\fR" 4
.IX Item "add_entity"
.Vb 1
\&  $anim\->add_entity( $entity1, $entity2, $entity3 );
.Ve
.Sp
Add one or more animation entities to the animation.
.IP "\fIdel_entity\fR" 4
.IX Item "del_entity"
.Vb 2
\&  $anim\->del_entity( $entity_name );
\&  $anim\->del_entity( $entity_ref );
.Ve
.Sp
Removes an entity from the animation. Accepts either an entity
name or a reference to the entity itself.
.IP "\fIremove_all_entities\fR" 4
.IX Item "remove_all_entities"
.Vb 1
\&  $anim\->remove_all_entities();
.Ve
.Sp
Removes every animation object. This is useful if you need to start the
animation over (eg. after a screen resize)
.IP "\fIentity_count\fR" 4
.IX Item "entity_count"
.Vb 1
\&  $number_of_entities = $anim\->entity_count();
.Ve
.Sp
Returns the number of entities in the animation.
.IP "\fIget_entities\fR" 4
.IX Item "get_entities"
.Vb 1
\&  $entity_list = $anim\->get_entities();
.Ve
.Sp
Returns a reference to a list of all entities in the animation.
.IP "\fIget_entities_of_type\fR" 4
.IX Item "get_entities_of_type"
.Vb 1
\&  $entity_list = $anim\->get_entities_of_type( $type );
.Ve
.Sp
Returns a reference to a list of all entities in the animation
that have the given type.
.IP "\fIis_living\fR" 4
.IX Item "is_living"
.Vb 1
\&  my $is_living = $anim\->is_living( $entity );
.Ve
.Sp
Return 1 if the entity name or reference is in the animation
and is not scheduled for deletion. Returns 0 otherwise.
.IP "\fIentity\fR" 4
.IX Item "entity"
.Vb 1
\&  $entity_ref = $anim\->entity( $entity_name );
.Ve
.Sp
If the animation contains an entity with the given name,
the Term::Animation::Entity object associated with the name
is returned. Otherwise, undef is returned.
.IP "\fIwidth\fR" 4
.IX Item "width"
.Vb 1
\&  $width = $anim\->width();
.Ve
.Sp
Returns the width of the screen
.IP "\fIheight\fR" 4
.IX Item "height"
.Vb 1
\&  $height = $anim\->height();
.Ve
.Sp
Returns the height of the screen
.IP "\fI\f(BIsize()\fI\fR" 4
.IX Item "size()"
.Vb 1
\&  $size = $anim\->size();
.Ve
.Sp
Returns the number of characters in the curses window (width * height)
.IP "\fIredraw_screen\fR" 4
.IX Item "redraw_screen"
.Vb 1
\&  $anim\->redraw_screen();
.Ve
.Sp
Clear everything from the screen, and redraw what should be there. This
should be called after \fIupdate_term_size\fR, or if the user indicates that
the screen should be redrawn to get rid of artifacts.
.IP "\fIgen_path\fR" 4
.IX Item "gen_path"
.Vb 1
\&  # gen_path (x,y,z, x,y,z, [ frame_pattern ], [ steps ])
\&
\&  $anim\->gen_path( $x1, $y1, $z1, $x2, $y2, $z2, [ 1, 2, 0, 2 ], \*(Aqlongest\*(Aq );
.Ve
.Sp
Given beginning and end points, this will return a path for the
entity to follow that can be given to the default callback routine,
\&\fImove_entity\fR. The first set of x,y,z coordinates are the point
the entity will begin at, the second set is the point the entity
will end at.
.Sp
You can optionally supply a list of frames to cycle through. The list
will be repeated as many times as needed to finish the path. If no
list of frames is supplied, only the first frame will be used.
.Sp
You can also request the number of steps you would like for the entity
to take to finish the path. The default is 'shortest'.
Valid arguments are:
  longest      The longer of the X and Y distances
  shortest     The shorter of the X and Y distances
  X,Y or Z     The x, y or z distance
  <number>     Explicitly specify the number of steps to take
.IP "\fIend\fR" 4
.IX Item "end"
.Vb 1
\&  $anim\->end();
.Ve
.Sp
Run the Curses endwin function to get your terminal back to its
normal mode. This is called automatically when the object is
destroyed if the animation is running full screen (if you 
did not pass an existing Curses window to the constructor).
.SH "CALLBACK ROUTINES"
.IX Header "CALLBACK ROUTINES"
Callback routines for all entities are called each time \fIanimate\fR
is called. A default callback routine is supplied, \fImove_entity\fR, which
is sufficient for most basic movement. If you want to create an entity
that exhibits more complex behavior, you will have to write a custom
callback routine for it.
.PP
Callback routines take two arguments, a reference to the Term::Animation::Entity
object that it should act on, and a reference to the Term::Animation instance
that called it. Any arguments required to tell the callback what to do with
the object, or any state that needs to be maintained, should be put
in the \fIcallback_args\fR element of the object. \fIcallback_args\fR is only
referenced by the callback routine, and thus can contain any datastructure
that you find useful.
.PP
Here is an example custom callback that will make an entity move randomly
around the screen:
.PP
.Vb 2
\&  sub random_movement {
\&      my ($entity, $anim) = @_;
\&
\&      # get the current position of the entity
\&      my ($x, $y, $z) = $entity\->position();
\&
\&      # we\*(Aqll use callback_args to store the last axis we moved in
\&      my $last_move = $entity\->callback_args();
\&
\&      # if we moved in x last time, move in y this time
\&      if($last_move eq \*(Aqx\*(Aq) {
\&          $entity\->callback_args(\*(Aqy\*(Aq);
\&          # move by \-1, 0 or 1
\&          $y += int(rand(3)) \- 1; 
\&      } else {
\&          $entity\->callback_args(\*(Aqx\*(Aq);
\&          $x += int(rand(3)) \- 1; 
\&      }
\&
\&      # return the absolute x,y,z coordinates to move to
\&      return ($x, $y, $z);
\&  }
.Ve
.PP
The return value of your callback routine should be of the form:
.PP
.Vb 1
\&    return ($x, $y, $z, $frame)
.Ve
.PP
\&\f(CW$x\fR, \f(CW$y\fR and \f(CW$z\fR represent the X, Y and Z coordinates to which the object
should move. \f(CW$frame\fR is the frame number that the object should display,
if it has multiple frames of animation. Any values that are unspecified
or undef will remain unchanged.
.PP
You can also call the default callback from within your callback, if
you want it to handle movement for you. For example, if your callback
is simply used to decide when an entity should die:
.PP
.Vb 2
\&  sub wait_for_file {
\&      my ($entity, $anim) = @_;
\&
\&      # kill this entity if a certain file shows up
\&      if(\-e "/path/to/file") {
\&          $entity\->kill();
\&          return();
\&      }
\&
\&      # use the default callback to handle the actual movement
\&      return $entity\->move_entity($anim);
\&  }
.Ve
.PP
If you use this, be aware that \fImove_entity\fR relies on
\&\fIcallback_args\fR, so you cannot use it to store your own
arbitrary data.
.SH "COLOR"
.IX Header "COLOR"
\&\s-1ANSI\s0 color is available for terminals that support it. Only a single
background color can be used for the window (it would look terrible
in most cases otherwise anyway). Colors for entities are specified by
using a 'mask' that indicates the color for each character. For
example, say we had a single frame of a bird:
.PP
.Vb 1
\&  $bird = q#
\&
\&  \-\-\-. .\-. .\-\-\-
\&    \-\-\e\*(Aqv\*(Aq/\-\-
\&       \e /
\&       " "
\&  #;
.Ve
.PP
To indicate the colors you want to use for the bird, create a matching
mask, with the first letter of each color in the appropriate position
(except black, which is 'k'). Pass this mask as the \fIcolor\fR parameter.
.PP
.Vb 1
\&  $mask = q#
\&
\&  BBBB BBB BBBB
\&    BBBWYWBBB
\&       B B
\&       Y Y
\&  #;
.Ve
.PP
When specifying a color, using uppercase indicates the color should be
bold. So '\s-1BLUE\s0' or 'B' means bold blue, and 'blue' or 'b' means non-bold
blue. 'Blue' means you get an error message.
.PP
You can also provide a default color with the default_color parameter.
This color will be used for any character that does
not have an entry in the mask. If you want the entire entity to be
a single color, you can just provide a default color with no mask.
.PP
The available colors are: red, green, blue, cyan, magenta, yellow, black
and white.
.PP
Here's an example call to build_object for the bird above.
.PP
.Vb 8
\&    $anim\->new_entity (
\&              name              => "Bird",
\&              shape             => $bird,
\&              position          => [ 5, 8, 7 ],
\&              callback_args     => [ 1, 2, 0, 0 ],
\&              color             => $mask,
\&              default_color     => "BLUE"
\&    );
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kirk Baucom, <kbaucom@schizoid.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Curses
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 179:" 4
.IX Item "Around line 179:"
alternative text 'Term::Animation::Entity/PARAMETERS' contains non-escaped | or /
.Sp
alternative text 'Term::Animation::Entity/new' contains non-escaped | or /
